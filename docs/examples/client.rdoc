=== Client Example

Here's a program which connects to a web server, sends a naive
request, parses the HTTP header of the response, and then
(antisocially) ends the event loop, which automatically drops the connection
(and incidentally calls the connection's unbind method).

 require 'rubygems'
 require 'eventmachine'
 
 module DumbHttpClient
 
   def post_init
     send_data "GET / HTTP/1.1\r\nHost: _\r\n\r\n"
     @data = ""
   end
 
   def receive_data data
     @data << data
     if  @data =~ /[\n][\r]*[\n]/m
       puts "RECEIVED HTTP HEADER:"
       $`.each {|line| puts ">>> #{line}" }
 
       puts "Now we'll terminate the loop, which will also close the connection"
       EventMachine::stop_event_loop
     end
   end
 
   def unbind
     puts "A connection has terminated"
   end
 
 end # DumbHttpClient
 
 
 EventMachine::run {
   EventMachine::connect "www.bayshorenetworks.com", 80, DumbHttpClient
 }
 puts "The event loop has ended"
 

There are times when it's more convenient to define a protocol handler
as a Class rather than a Module. Here's how to do this:

 class MyProtocolHandler < EventMachine::Connection
   def initialize *args
     super
     # whatever else you want to do here
   end
   
   #.......your other class code
 end # class MyProtocolHandler

If you do this, then an instance of your class will be instantiated to handle
every network connection created by your code or accepted by servers that you
create. If you redefine #post_init in your protocol-handler class, your
#post_init method will be called _inside_ the call to #super that you will
make in your #initialize method (if you provide one).
