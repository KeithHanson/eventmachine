== Introduction

EventMachine provides a fast, lightweight framework for implementing
Ruby programs that can use the network to communicate with other
processes. Using EventMachine, Ruby programmers can easily connect
to remote servers and act as servers themselves. EventMachine does not
supplant the Ruby IP libraries. It does provide an alternate technique
for those applications requiring better performance, scalability,
and discipline over the behavior of network sockets, than is easily
obtainable using the built-in libraries, especially in applications
which are structurally well-suited for the event-driven programming model.

EventMachine provides a perpetual event-loop which your programs can
start and stop. Within the event loop, TCP network connections are
initiated and accepted, based on EventMachine methods called by your
program. You also define callback methods which are called by EventMachine
when events of interest occur within the event-loop.

User programs will be called back when the following events occur:
* When the event loop accepts network connections from remote peers
* When data is received from network connections
* When connections are closed, either by the local or the remote side
* When user-defined timers expire

== Usage example

Here's a fully-functional echo server implemented in EventMachine:

      require 'rubygems'
      require 'eventmachine'

      module EchoServer
        def receive_data data
          send_data ">>>you sent: #{data}"
          close_connection if data =~ /quit/i
        end
      end

      EventMachine::run {
        EventMachine::start_server "192.168.0.100", 8081, EchoServer
      }

What's going on here? Well, we have defined the module EchoServer to
implement the semantics of the echo protocol (more about that shortly).
The last three lines invoke the event-machine itself, which runs forever
unless one of your callbacks terminates it. The block that you supply
to EventMachine::run contains code that runs immediately after the event
machine is initialized and before it starts looping. This is the place
to open up a TCP server by specifying the address and port it will listen
on, together with the module that will process the data.

Our EchoServer is extremely simple as the echo protocol doesn't require
much work. Basically you want to send back to the remote peer whatever
data it sends you. We'll dress it up with a little extra text to make it
interesting. Also, we'll close the connection in case the received data
contains the word "quit."

So what about this module EchoServer? Well, whenever a network connection
(either a client or a server) starts up, EventMachine instantiates an anonymous
class, that your module has been mixed into. Exactly one of these class
instances is created for each connection. Whenever an event occurs on a
given connection, its corresponding object automatically calls specific
instance methods which your module may redefine. The code in your module
always runs in the context of a class instance, so you can create instance
variables as you wish and they will be carried over to other callbacks
made on that same connection.

Looking back up at EchoServer, you can see that we've defined the method
receive_data which (big surprise) is called whenever data has been received
from the remote end of the connection. Very simple. We get the data
(a String object) and can do whatever we wish with it. In this case,
we use the method send_data to return the received data to the caller,
with some extra text added in. And if the user sends the word "quit,"
we'll close the connection with (naturally) close_connection.
(Notice that closing the connection doesn't terminate the processing loop,
or change the fact that your echo server is still accepting connections!) 


== Questions and Futures

Would it be useful for EventMachine to incorporate the Observer pattern
and make use of the corresponding Ruby <tt>observer</tt> package?
Interesting thought.
